# Hashable

Type must be Hashable to be used in a Set or as the key type of a Dictionary.  
A struct whose properties are all Hashable, or an enum whose associated values are all Hashable, can conform to Hashable merely by declaring that it adopts Hashable.

Hashable requires that its adopter, in addition to being Equatable, have a hashValue Int property;  
the idea is that two equal objects should have equal hash values.  
The implicit implementation combines the hashValue of the Hashable members to produce a hashValue for the object itself.  

But suppose you don’t like the synthesized implementation of hashValue.  
Swift gives you a way to do that. You ignore hashValue, and instead implement the `hash(into:)` method.  
There is then no need to implement hashValue, because it is autogenerated based on the result of hash(into:).  
In this method, you are handed a Hasher object; you call hash(into:) with that object on every property that you want included in the hash calculation and omit the ones you don’t

For hashability to work properly, these should be the very same properties you’ve included in the Equatable calculation of ==.
```swift
struct Dog : Hashable { // and therefore Equatable
  let name : String
  let license : Int
  let color : UIColor
  static func ==(lhs:Dog,rhs:Dog) -> Bool {
    return lhs.name == rhs.name && lhs.license == rhs.license
  }
  
  func hash(into hasher: inout Hasher) {
    name.hash(into: &hasher)
    license.hash(into: &hasher)
  }
}
```
